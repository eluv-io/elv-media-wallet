

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" href="images/favicon.png" >

  <title>
    ClientMethods.js - Documentation
  </title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/elv-jsdoc.css">
  <link type="text/css" rel="stylesheet" href="styles/elv-prettify-jsdoc.css">
</head>

<body>
  <div class="layout-container">
    <nav class="nav-container">
      <div class="header">
        <a href="index.html">
          <img class="logo" src="images/logo-dark.png" />
        </a>
        <div class="title">
          Eluvio Media Wallet
        </div>
      </div>
      <div class="nav-content">
        <h3>Classes</h3><ul><li id="ElvWalletClient-nav">
          <div data-name="ElvWalletClient" class="class-link-container"><a class="class-link">ElvWalletClient</a></div><ul class='methods'><h4 class="methodGroupHeader">Constructor</h4><li data-type="method" id="ElvWalletClient-ElvWalletClient-nav"><a href="ElvWalletClient.html" class="method-link">ElvWalletClient</a></li><li data-type="method" id="ElvWalletClient-InitializeFrame-nav"><a href="ElvWalletClient.html#.InitializeFrame" class="method-link">InitializeFrame</a></li><li data-type="method" id="ElvWalletClient-InitializePopup-nav"><a href="ElvWalletClient.html#.InitializePopup" class="method-link">InitializePopup</a></li><h4 class="methodGroupHeader">Authorization</h4><li data-type="method" id="ElvWalletClient-SignIn-nav"><a href="ElvWalletClient.html#SignIn" class="method-link">SignIn</a></li><li data-type="method" id="ElvWalletClient-SignOut-nav"><a href="ElvWalletClient.html#SignOut" class="method-link">SignOut</a></li><h4 class="methodGroupHeader">Events</h4><li data-type="method" id="ElvWalletClient-AddEventListener-nav"><a href="ElvWalletClient.html#AddEventListener" class="method-link">AddEventListener</a></li><li data-type="method" id="ElvWalletClient-Events-nav"><a href="ElvWalletClient.html#Events" class="method-link">Events</a></li><li data-type="method" id="ElvWalletClient-RemoveEventListener-nav"><a href="ElvWalletClient.html#RemoveEventListener" class="method-link">RemoveEventListener</a></li><h4 class="methodGroupHeader">Navigation</h4><li data-type="method" id="ElvWalletClient-CurrentPath-nav"><a href="ElvWalletClient.html#CurrentPath" class="method-link">CurrentPath</a></li><li data-type="method" id="ElvWalletClient-Navigate-nav"><a href="ElvWalletClient.html#Navigate" class="method-link">Navigate</a></li><li data-type="method" id="ElvWalletClient-Reload-nav"><a href="ElvWalletClient.html#Reload" class="method-link">Reload</a></li><li data-type="method" id="ElvWalletClient-ToggleDarkMode-nav"><a href="ElvWalletClient.html#ToggleDarkMode" class="method-link">ToggleDarkMode</a></li><li data-type="method" id="ElvWalletClient-ToggleNavigation-nav"><a href="ElvWalletClient.html#ToggleNavigation" class="method-link">ToggleNavigation</a></li><li data-type="method" id="ElvWalletClient-ToggleSidePanelMode-nav"><a href="ElvWalletClient.html#ToggleSidePanelMode" class="method-link">ToggleSidePanelMode</a></li></ul></li></ul><h3>Modules</h3><ul><li id="ElvWalletClient_Methods-nav">
          <div data-name="ElvWalletClient/Methods" class="class-link-container"><a class="class-link">ElvWalletClient/Methods</a></div><ul class='methods'><li data-type="method" id="ElvWalletClient_Methods-ElvWalletClient/Methods-nav"><a href="module-ElvWalletClient_Methods.html" class="method-link">ElvWalletClient/Methods</a></li><h4 class="methodGroupHeader">Event</h4><li data-type="method" id="ElvWalletClient_Methods-EventMetadata-nav"><a href="module-ElvWalletClient_Methods.html#.EventMetadata" class="method-link">EventMetadata</a></li><h4 class="methodGroupHeader">Items</h4><li data-type="method" id="ElvWalletClient_Methods-Item-nav"><a href="module-ElvWalletClient_Methods.html#.Item" class="method-link">Item</a></li><li data-type="method" id="ElvWalletClient_Methods-ItemNames-nav"><a href="module-ElvWalletClient_Methods.html#.ItemNames" class="method-link">ItemNames</a></li><li data-type="method" id="ElvWalletClient_Methods-Items-nav"><a href="module-ElvWalletClient_Methods.html#.Items" class="method-link">Items</a></li><h4 class="methodGroupHeader">Listings</h4><li data-type="method" id="ElvWalletClient_Methods-EditListing-nav"><a href="module-ElvWalletClient_Methods.html#.EditListing" class="method-link">EditListing</a></li><li data-type="method" id="ElvWalletClient_Methods-Listing-nav"><a href="module-ElvWalletClient_Methods.html#.Listing" class="method-link">Listing</a></li><li data-type="method" id="ElvWalletClient_Methods-ListingPayout-nav"><a href="module-ElvWalletClient_Methods.html#.ListingPayout" class="method-link">ListingPayout</a></li><li data-type="method" id="ElvWalletClient_Methods-Listings-nav"><a href="module-ElvWalletClient_Methods.html#.Listings" class="method-link">Listings</a></li><li data-type="method" id="ElvWalletClient_Methods-ListItem-nav"><a href="module-ElvWalletClient_Methods.html#.ListItem" class="method-link">ListItem</a></li><li data-type="method" id="ElvWalletClient_Methods-RemoveListing-nav"><a href="module-ElvWalletClient_Methods.html#.RemoveListing" class="method-link">RemoveListing</a></li><li data-type="method" id="ElvWalletClient_Methods-UserListings-nav"><a href="module-ElvWalletClient_Methods.html#.UserListings" class="method-link">UserListings</a></li><h4 class="methodGroupHeader">Marketplace</h4><li data-type="method" id="ElvWalletClient_Methods-ClearMarketplaceFilters-nav"><a href="module-ElvWalletClient_Methods.html#.ClearMarketplaceFilters" class="method-link">ClearMarketplaceFilters</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplaceItem-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplaceItem" class="method-link">MarketplaceItem</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplaceItems-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplaceItems" class="method-link">MarketplaceItems</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplaceMetadata-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplaceMetadata" class="method-link">MarketplaceMetadata</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplaceStock-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplaceStock" class="method-link">MarketplaceStock</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplaceStorefront-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplaceStorefront" class="method-link">MarketplaceStorefront</a></li><li data-type="method" id="ElvWalletClient_Methods-SetMarketplace-nav"><a href="module-ElvWalletClient_Methods.html#.SetMarketplace" class="method-link">SetMarketplace</a></li><li data-type="method" id="ElvWalletClient_Methods-SetMarketplaceFilters-nav"><a href="module-ElvWalletClient_Methods.html#.SetMarketplaceFilters" class="method-link">SetMarketplaceFilters</a></li><h4 class="methodGroupHeader">Packs</h4><li data-type="method" id="ElvWalletClient_Methods-OpenPack-nav"><a href="module-ElvWalletClient_Methods.html#.OpenPack" class="method-link">OpenPack</a></li><li data-type="method" id="ElvWalletClient_Methods-PackOpenStatus-nav"><a href="module-ElvWalletClient_Methods.html#.PackOpenStatus" class="method-link">PackOpenStatus</a></li><h4 class="methodGroupHeader">Purchases</h4><li data-type="method" id="ElvWalletClient_Methods-ListingPurchase-nav"><a href="module-ElvWalletClient_Methods.html#.ListingPurchase" class="method-link">ListingPurchase</a></li><li data-type="method" id="ElvWalletClient_Methods-MarketplacePurchase-nav"><a href="module-ElvWalletClient_Methods.html#.MarketplacePurchase" class="method-link">MarketplacePurchase</a></li><li data-type="method" id="ElvWalletClient_Methods-PurchasePrice-nav"><a href="module-ElvWalletClient_Methods.html#.PurchasePrice" class="method-link">PurchasePrice</a></li><li data-type="method" id="ElvWalletClient_Methods-PurchaseStatus-nav"><a href="module-ElvWalletClient_Methods.html#.PurchaseStatus" class="method-link">PurchaseStatus</a></li><h4 class="methodGroupHeader">Stats</h4><li data-type="method" id="ElvWalletClient_Methods-ListingStats-nav"><a href="module-ElvWalletClient_Methods.html#.ListingStats" class="method-link">ListingStats</a></li><li data-type="method" id="ElvWalletClient_Methods-Sales-nav"><a href="module-ElvWalletClient_Methods.html#.Sales" class="method-link">Sales</a></li><li data-type="method" id="ElvWalletClient_Methods-SalesStats-nav"><a href="module-ElvWalletClient_Methods.html#.SalesStats" class="method-link">SalesStats</a></li><h4 class="methodGroupHeader">User</h4><li data-type="method" id="ElvWalletClient_Methods-UserBalances-nav"><a href="module-ElvWalletClient_Methods.html#.UserBalances" class="method-link">UserBalances</a></li><li data-type="method" id="ElvWalletClient_Methods-UserProfile-nav"><a href="module-ElvWalletClient_Methods.html#.UserProfile" class="method-link">UserProfile</a></li><li data-type="method" id="ElvWalletClient_Methods-UserTransferHistory-nav"><a href="module-ElvWalletClient_Methods.html#.UserTransferHistory" class="method-link">UserTransferHistory</a></li></ul></li></ul>
      </div>
    </nav>

    <div class="main">
      <div class="header"></div>
      <div class="main-content">
        
        <h1 class="page-title">
          ClientMethods.js
        </h1>
        

        
      

<a class="button" href="ClientMethods.html">Back</a>
<div class="source-container">
  <pre class="prettyprint source linenums"><code>/**
 * Methods for accessing information from the wallet and performing actions
 *
 * @module ElvWalletClient/Methods
 */

const Assert = (method, name, value) => {
  if(!value) {
    throw Error(`Eluvio Wallet Client: ${name} not specified in ${method} call`);
  }
};

/**
 * Set the marketplace for the wallet.
 *
 * This will update the font, color scheme, bottom navigation and login customization to the settings of the marketplace specified.
 *
 * Note that this is not required if the client was initialized with a marketplace.
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of your tenant. Required if specifying marketplaceSlug
 * @param {string=} marketplaceSlug - Specify the URL slug of your marketplace
 *
 * @returns {Promise&lt;string>} - The version hash of the specified marketplace
 */
exports.SetMarketplace = async function ({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash}) {
  return this.SendMessage({
    action: "setMarketplace",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash
    }}
  );
};

/**
 * Set filters for the marketplace store view. When active, only items with matching tags will be shown in the marketplace
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param filters - The filter(s) to be applied
 */
exports.SetMarketplaceFilters = async function ({filters=[]}) {
  return this.SendMessage({action: "setMarketplaceFilters", params: { filters }});
};

/**
 * Clear all marketplace filters
 *
 * @methodGroup Marketplace
 */
exports.ClearMarketplaceFilters = async function () {
  return this.SendMessage({action: "setMarketplaceFilters", params: { filters: [] }});
};

/**
 * Retrieve available item stock for the specified marketplace. Items are keyed by their SKU. If an item's stock is not restricted,
 * no entry will be present. If a user is currently logged in, the entry will contain the number of that item the current user owns.

 * @methodGroup Marketplace
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of your tenant. Required if specifying marketplaceSlug
 * @param {string=} marketplaceSlug - Specify the URL slug of your marketplace
 * @param {string=} marketplaceId - The ID of the marketplace
 * @param {string=} marketplaceHash - A version hash of the marketplace
 *
 * @returns {Promise&lt;Object>} - Information about available stock in the specified marketplace
 */
exports.MarketplaceStock = async function ({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash}) {
  return this.SendMessage({action: "stock", params: { tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash }});
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Return the current user's profile, including name, email and blockchain address.
 *
 * @methodGroup User
 * @returns {Promise&lt;Object>} - If a user is currently logged in, the user's profile is returned.
 */
exports.UserProfile = async function () {
  return await this.SendMessage({
    action: "profile",
    params: {}
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the fund balances for the current user
 *
 * @methodGroup User
 * @returns {Promise&lt;Object>} - Returns balances for the user. All values are in USD.
 &lt;ul>
 &lt;li>- totalWalletBalance - Total balance of the users sales and wallet balance purchases&lt;/li>
 &lt;li>- availableWalletBalance - Balance available for purchasing items&lt;/li>
 &lt;li>- pendingWalletBalance - Balance unavailable for purchasing items&lt;/li>
 &lt;li>- withdrawableWalletBalance - Amount that is available for withdrawal&lt;/li>
 &lt;li>- usedBalance - &lt;i>(Only included if user has set up Solana link with the Phantom wallet)&lt;/i> Available USDC balance of the user's Solana wallet&lt;/li>
 &lt;/ul>
 */
exports.UserBalances = async function() {
  return await this.SendMessage({
    action: "balances",
    params: {}
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the transfer history for the current user, including purchases, sales and balance withdrawals. Transactions are sorted by newest first.
 *
 * @methodGroup User
 * @returns {Promise&lt;Object>} - The transfer history of the current user
 */
exports.UserTransferHistory = async function () {
  return await this.SendMessage({
    action: "userTransferHistory",
    params: {}
  });
};

/**
 * Retrieve the full metadata for the specified marketplace object (starting from `/public/asset_metadata/info`)
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Specify the URL slug of the marketplace
 *
 */
exports.MarketplaceMetadata = async function ({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash}) {
  return await this.SendMessage({
    action: "marketplaceMetadata",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash
    }
  });
};

/**
 * Retrieve the full metadata for the specified event object (starting from `/public/asset_metadata`)
 *
 * @methodGroup Event
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of the event's tenant. Required if specifying event slug
 * @param {string=} eventSlug - Specify the URL slug of the event
 * @param {string=} eventHash - Specify a specific version of a the event. Not necessary if eventSlug is specified
 *
 * @returns {Promise&lt;Object>} - The full metadata of the event
 */
exports.EventMetadata = async function ({tenantSlug, eventSlug, eventId, eventHash}) {
  return await this.SendMessage({
    action: "eventMetadata",
    params: {
      tenantSlug,
      eventSlug,
      eventId,
      eventHash
    }
  });
};

/**
 * Retrieve all items from the specified marketplace.
 *
 * Note that this includes items that may not be for displayed sale in the marketplace. For information specifically about items displayed
 * for sale, see the &lt;a href="#.MarketplaceStorefront">MarketplaceStorefront method&lt;/a>.
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param {string} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string} marketplaceSlug - Specify the URL slug of the marketplace
 * @param {Array&lt;string>=} tags - A list of tags to filter the results. Items not containing at least one specified tag (case insensitive) will be excluded.
 */
exports.MarketplaceItems = async function({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash, tags}) {
  return await this.SendMessage({
    action: "marketplaceItems",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash,
      tags
    }
  });
};

/**
 * Retrieve the specified item from the specified marketplace
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param {string} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string} marketplaceSlug - Specify the URL slug of the marketplace
 * @param {string} sku - The SKU of the item
 */
exports.MarketplaceItem = async function({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash, sku}) {
  return await this.SendMessage({
    action: "marketplaceItem",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash,
      sku
    }
  });
};


/**
 * Retrieve information about the items displayed for sale in the specified marketplace
 *
 * @methodGroup Marketplace
 * @namedParams
 * @param {string} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string} marketplaceSlug - Specify the URL slug of the marketplace
 * @param {Array&lt;string>=} tags - A list of tags to filter the results. Items not containing at least one specified tag (case insensitive) will be excluded.
 * Storefront sections with no matching items will be omitted
 */
exports.MarketplaceStorefront = async function({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash, tags}) {
  return await this.SendMessage({
    action: "marketplaceStorefront",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash,
      tags
    }
  });
};

/**
 * &lt;b>&lt;i>Note: Will either prompt user for consent (wallet balance) or open the third party payment flow in a new tab (stripe, coinbase) unless the item is free to claim&lt;/i>&lt;/b>
 *
 * Initiate purchase/claim flow for the specified item
 *
 * @methodGroup Purchases
 * @namedParams
 * @param {string} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string} marketplaceSlug - Specify the URL slug of the marketplace
 * @param {string=} purchaseProvider=stripe - The payment flow to use for the purchase. Not required if the item can be claimed for free. Available providers:
 &lt;ul>
 &lt;li>- stripe - Credit card payment flow with stripe&lt;/li>
 &lt;li>- coinbase - Crypto payment flow with Coinbase&lt;/li>
 &lt;li>- wallet-balance - Purchase with the user's available wallet balance (&lt;b>Requires consent prompt&lt;/b>).&lt;/li>
 &lt;/ul>
 &lt;br />
 &lt;b>Note&lt;/b>: Use the &lt;a href="#.UserBalances"> UserBalances method&lt;/a> to check the user's available balance.
 * @param {string} sku - SKU ID of the item to purchase
 * @param {number=} quantity=1 - Quantity of the item to purchase. It is recommended to check the &lt;a href="#.MarketplaceStock">MarketplaceStock API&lt;/a> to ensure enough quantity is available.
 *
 * @returns {Promise&lt;string>} - The confirmation ID of the purchase. This ID can be used to check purchase and minting status via the &lt;a href="#.PurchaseStatus">PurchaseStatus method&lt;/a>.
 */
exports.MarketplacePurchase = async function({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash, purchaseProvider, sku, quantity}) {
  return await this.SendMessage({
    action: "marketplacePurchase",
    params: {
      provider: purchaseProvider,
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash,
      sku,
      quantity
    }
  });
};

/**
 * Retrieve names of all valid items. Full item names are required for filtering results by name.
 *
 * Specify marketplace information to filter the results to only items offered in that marketplace.
 *
 * @methodGroup Items
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of a marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Specify the URL slug of a marketplace
 *
 * @returns {Promise&lt;Array&lt;String>>} - A list of item names
 */
exports.ItemNames = async function({tenantSlug, marketplaceSlug, marketplaceId, marketplaceHash}={}) {
  return await this.SendMessage({
    action: "itemNames",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Return info about items in the user's wallet
 *
 * &lt;i>Note - Certain information (for example additional media and attributes) is not included in item results for efficiency purposes. Use `client.Item` to retrieve full NFT info&lt;/i>
 *
 * @methodGroup Items
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of the marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Specify the URL slug of the marketplace to filter items by marketplace
 * @param {string=} sortBy=default - Sort order for the results - either `default` or `meta/display_name`
 * @param {boolean=} sortDesc=false - Sort in descending order
 * @param {string=} filter - Filter results by item name
 * @param {string=} contractAddress - Filter results by contract address
 *
 * @methodGroup Items
 * @returns {Promise&lt;Array&lt;Object>>} - Information about the items in the user's wallet.
 */
exports.Items = async function ({
  tenantSlug,
  marketplaceSlug,
  sortBy="default",
  sortDesc=false,
  filter,
  contractAddress
}={}) {
  return await this.SendMessage({
    action: "items",
    params: {
      tenantSlug,
      marketplaceSlug,
      sortBy,
      sortDesc,
      filter,
      contractAddress
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Return info about a specific item in the user's wallet
 *
 * @methodGroup Items
 * @namedParams
 * @param {string} contractAddress - The address of the NFT contract
 * @param {string} tokenId - The token ID of the item
 *
 * @returns {Promise&lt;Object>} - Information about the requested item. Returns undefined if the item was not found.
 */
exports.Item = async function ({contractAddress, tokenId}) {
  Assert("Item", "Contract address", contractAddress);
  Assert("Item", "Token ID", tokenId);

  return await this.SendMessage({
    action: "item",
    params: {
      contractAddress,
      tokenId: tokenId.toString()
    }
  });
};

/**
 * * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve the exact listing payout breakdown for the specified owned NFT at the specified price
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} contractAddress - The contract address of the NFT
 * @param {string} tokenId - The token ID of the NFT
 * @param {number} listingPrice - The desired listing price of the NFT
 *
 * @returns {Promise&lt;Object>} - The breakdown of the payout for the listing, including the royalty rate, total royalty fee, and ultimate payout to the user
 */
exports.ListingPayout = async function({contractAddress, tokenId, listingPrice}) {
  return this.SendMessage({
    action: "listingPayout",
    params: {
      contractAddress,
      tokenId,
      listingPrice
    }}
  );
};

/**
 * Return available listings
 *
 * @methodGroup Listings
 * @namedParams
 * @param {number=} start=0 - Index to start listing at
 * @param {number=} limit=50 - Maximum number of results to return
 * @param {string=} sortBy=created - Sort order for the results. Available sort options:
 &lt;ul>
  &lt;li>- created&lt;/li>
  &lt;li>- info/ordinal&lt;/li>
  &lt;li>- price&lt;/li>
  &lt;li>- nft/display_name&lt;/li>
 &lt;/ul>
 * @param {boolean=} sortDesc=false - Sort in descending order
 * @param {string=} filter - Filter results by item name.
 &lt;br />&lt;br />
 NOTE: This string must be an &lt;b>exact match&lt;/b> on the item name.
 * You can retrieve all available item names from the &lt;a href="#.ItemNames">ItemNames method&lt;/a>.
 * @param {string=} tenantSlug - Specify the URL slug of a marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Filter listings by marketplace
 * @param {string=} contractAddress - Filter results by contract address
 * @param {string=} tokenId - Filter by specific token (along with contract address)
 * @param {number=} lastNDays - Limit results to only include items listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Available listings and pagination information
 */
exports.Listings = async function ({
  start=0,
  limit=50,
  tenantSlug,
  marketplaceSlug,
  marketplaceId,
  marketplaceHash,
  sortBy="created",
  sortDesc=false,
  filter,
  contractAddress,
  tokenId,
  lastNDays
}={}) {
  return await this.SendMessage({
    action: "listings",
    params: {
      start,
      limit,
      marketplaceSlug,
      tenantSlug,
      marketplaceId,
      marketplaceHash,
      sortBy,
      sortDesc,
      filter,
      contractAddress,
      tokenId,
      lastNDays
    }
  });
};

/**
 * Return stats about currently active listings
 *
 * @methodGroup Stats
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of a marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Filter stats by marketplace
 * @param {string=} contractAddress - Filter results by contract address
 * @param {string=} tokenId - Filter results by individual token (along with contract address)
 * @param {number=} lastNDays - Limit results to only include items listed in the past N days
 *
 * @returns {Promise&lt;Object>} - Stats for currently active listings matching the specified filters. All monetary values are in USD.
 &lt;ul>
 &lt;li>- count - Total number of listed items
 &lt;li>- avg - Average listing price
 &lt;li>- max - Maximum listing price
 &lt;li>- min - Minimum listing price
 &lt;li>- volume - Total volume, in USD, of all listings
 &lt;/ul>
 */
exports.ListingStats = async function ({
  tenantSlug,
  marketplaceSlug,
  marketplaceId,
  marketplaceHash,
  contractAddress,
  tokenId,
  lastNDays
}={}) {
  return await this.SendMessage({
    action: "listingStats",
    params: {
      marketplaceSlug,
      tenantSlug,
      marketplaceId,
      marketplaceHash,
      contractAddress,
      tokenId,
      lastNDays
    }
  });
};

/**
 * Return stats about listing sales
 *
 * @methodGroup Stats
 * @namedParams
 * @param {string=} tenantSlug - Specify the URL slug of a marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Filter stats by marketplace
 * @param {string=} contractAddress - Filter results by contract address
 * @param {string=} tokenId - Filter results by individual token (along with contract address)
 * @param {number=} lastNDays - Limit results to only include items sold in the past N days
 *
 * @returns {Promise&lt;Object>} - Stats for listing sales matching the specified filters. All monetary values are in USD.
 &lt;ul>
 &lt;li>- count - Total number of sales
 &lt;li>- avg - Average sale
 &lt;li>- max - Maximum sale
 &lt;li>- min - Minimum sale
 &lt;li>- volume - Total volume, in USD, of all sales
 &lt;/ul>
 */
exports.SalesStats = async function ({
  tenantSlug,
  marketplaceSlug,
  marketplaceId,
  marketplaceHash,
  contractAddress,
  tokenId,
  lastNDays
}={}) {
  return await this.SendMessage({
    action: "salesStats",
    params: {
      marketplaceSlug,
      tenantSlug,
      marketplaceId,
      marketplaceHash,
      contractAddress,
      tokenId,
      lastNDays
    }
  });
};


/**
 * Return records about sales
 *
 * @methodGroup Stats
 * @namedParams
 * @param {number=} start=0 - Index to start listing at
 * @param {number=} limit=50 - Maximum number of results to return
 * @param {string=} sortBy=created - Sort order for the results. Available sort options:
 *  &lt;ul>
 *   &lt;li>- created&lt;/li>
 *   &lt;li>- price&lt;/li>
 *   &lt;li>- name&lt;/li>
 *  &lt;/ul>
 * @param {boolean=} sortDesc=false - Sort in descending order
 * @param {string=} tenantSlug - Specify the URL slug of a marketplace's tenant. Required if specifying marketplace slug
 * @param {string=} marketplaceSlug - Filter results by marketplace
 * @param {string=} contractAddress - Filter results by contract address
 * @param {string=} tokenId - Filter results by individual token (along with contract address)
 * @param {number=} lastNDays - Limit results to only include items sold in the past N days
 *
 * @returns {Promise&lt;Object>} - List of sales records  matching the specified filters. All monetary values are in USD.
 */
exports.Sales = async function ({
  start=0,
  limit=50,
  sortBy="created",
  sortDesc=false,
  tenantSlug,
  marketplaceSlug,
  marketplaceId,
  marketplaceHash,
  contractAddress,
  tokenId,
  lastNDays
}={}) {
  return await this.SendMessage({
    action: "activity",
    params: {
      start,
      limit,
      sortBy,
      sortDesc,
      marketplaceSlug,
      tenantSlug,
      marketplaceId,
      marketplaceHash,
      contractAddress,
      tokenId,
      lastNDays
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * Retrieve all listings posted by the current user.
 *
 * @methodGroup Listings
 * @namedParams
 *
 * @returns {Promise&lt;Array&lt;Object>>} - The current user's listings
  */
exports.UserListings = async function () {
  return await this.SendMessage({
    action: "userListings"
  });
};

/**
 * Return info about a specific item in the user's wallet
 *
 * @methodGroup Listings
 * @namedParams
 * @param {string} listingId - The ID of the listing to retrieve
 *
 * @returns {Promise&lt;Object>} - Information about the requested listing. Returns undefined if the item was not found.
 */
exports.Listing = async function ({listingId}) {
  Assert("Listing", "Listing ID", listingId);

  return await this.SendMessage({
    action: "listing",
    params: {
      listingId
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * &lt;b>&lt;i>Prompts user for consent&lt;/i>&lt;/b>
 *
 * List the specified item for sale. The item must be owned by the current user, and must not have an active hold. (`nft.details.TokenHold`)
 *
 * @methodGroup Listings
 * @param {string} contractAddress - The address of the NFT contract
 * @param {string} tokenId - The token ID of the item
 * @param {number} price - Price for the item, in USD. The maximum listing price is $10,000
 *
 * @returns {Promise&lt;string>} - The listing ID of the item
 */
exports.ListItem = async function({contractAddress, tokenId, price}) {
  Assert("ListItem", "Contract address", contractAddress);
  Assert("ListItem", "Token ID", tokenId);
  Assert("ListItem", "Price", price);

  return await this.SendMessage({
    action: "listItem",
    params: {
      contractAddress,
      tokenId,
      price
    }
  });
};


/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * &lt;b>&lt;i>Prompts user for consent&lt;/i>&lt;/b>
 *
 * Modify the specify listing. Provide either the listing's ID, or the contract address and token ID of the listed item.
 *
 * @methodGroup Listings
 * @param {string=} listingId - The listing ID of the listing to change
 * @param {string=} contractAddress - The address of the NFT contract
 * @param {string=} tokenId - The token ID of the item
 * @param {number} price - Price for the item, in USD. The maximum listing price is $10,000
 */
exports.EditListing = async function({listingId, contractAddress, tokenId, price}) {
  Assert("EditListing", "Listing ID or Contract Address and Token ID", listingId || (contractAddress &amp;&amp; tokenId));
  Assert("ListItem", "Price", price);

  return await this.SendMessage({
    action: "editListing",
    params: {
      listingId,
      contractAddress,
      tokenId,
      price
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * &lt;b>&lt;i>Prompts user for consent&lt;/i>&lt;/b>
 *
 * Modify the specify listing. Provide either the listing's ID, or the contract address and token ID of the listed item.
 *
 * @methodGroup Listings
 * @param {string=} listingId - The listing ID of the listing to remove
 * @param {string=} contractAddress - The address of the NFT contract
 * @param {string=} tokenId - The token ID of the item
 */
exports.RemoveListing = async function({listingId, contractAddress, tokenId}) {
  Assert("RemoveListing", "Listing ID or Contract Address and Token ID", listingId || (contractAddress &amp;&amp; tokenId));

  return await this.SendMessage({
    action: "removeListing",
    params: {
      listingId,
      contractAddress,
      tokenId
    }
  });
};

/**
 * &lt;b>&lt;i>Requires login&lt;/i>&lt;/b>
 *
 * &lt;b>&lt;i>Note: Will either prompt user for consent (wallet balance, linked solana wallet) or open the third party payment flow in a new tab (stripe, coinbase)&lt;/i>&lt;/b>
 *
 * Initiate purchase flow for the specified listing
 *
 * @methodGroup Purchases
 * @namedParams
 * @param {string} listingId - The ID of the listing to purchase
 * @param {string} purchaseProvider=stripe - The payment flow to use for the purchase. Available providers:
 &lt;ul>
 &lt;li>- stripe - Credit card payment flow with stripe&lt;/li>
 &lt;li>- coinbase - Crypto payment flow with Coinbase&lt;/li>
 &lt;li>- wallet-balance - Purchase with the user's available wallet balance (&lt;b>Requires consent prompt&lt;/b>).&lt;/li>
 &lt;li>- linked-wallet - Purchase item with USDC on Solana using the Phantom wallet (&lt;b>Requires popup prompt&lt;/b>)&lt;/li>
 &lt;/ul>
 &lt;br />
 &lt;b>Note&lt;/b>: Use the &lt;a href="#.UserBalances"> UserBalances method&lt;/a> to check the user's available balance.
 *
 * @returns {Promise&lt;string>} - The confirmation ID of the purchase. This ID can be used to check purchase and minting status via the &lt;a href="#.PurchaseStatus">PurchaseStatus method&lt;/a>.
 */
exports.ListingPurchase = async function({listingId, purchaseProvider="stripe"}) {
  Assert("ListingPurchase", "Listing ID", listingId);

  return await this.SendMessage({
    action: "listingPurchase",
    params: {
      listingId,
      provider: purchaseProvider
    }
  });
};

/**
 * Retrieve the status of the specified purchase.
 *
 * The returned status has three parts:
 &lt;ul>
 &lt;li>- purchase - The status of the purchase flow. When the user has completed the process, this status will be COMPLETE. If the user aborts the purchase flow, this status will be CANCELLED.&lt;/li>
 &lt;li>- minting - The status of the nft minting/transfer process. When the minting/transfer has finished, this status will be COMPLETE. If the process failed, this status will be FAILED.&lt;/li>
 &lt;li>- items - If minting has been completed, a list of the items received will be included.&lt;/li>
 &lt;ul>
 *
 * @methodGroup Purchases
 * @namedParams
 * @param {string} confirmationId - The confirmation ID of the purchase
 *
 * @return {Promise&lt;Object>} - The status of the purchase
 */
exports.PurchaseStatus = async function({confirmationId}) {
  Assert("PurchaseStatus", "Confirmation ID", confirmationId);

  return await this.SendMessage({
    action: "purchaseStatus",
    params: {
      confirmationId
    }
  });
};

/**
 * Retrieve the exact purchase price breakdown of the specified marketplace item or listing. Includes quantity and fee calculations.
 *
 * @methodGroup Purchases
 * @namedParams
 * @param {string=} tenantSlug - The URL slug of a tenant. Required if specifying marketplaceSlug
 * @param {string=} marketplaceSlug - The URL slug of a marketplace
 * @param {string=} sku - The SKU of an item from a marketplace
 * @param {string=} listingId - The listing ID of an item
 * @param {number=} quantity=1 - For marketplace purchases, the number of items to purchase
 *
 * @returns {Promise&lt;Object>} - The price of the purchase, including individual item price, subtotal, calculated fees and the total purchase price.
 */
exports.PurchasePrice = async function({tenantSlug, marketplaceSlug, marketplaceHash, marketplaceId, listingId, sku, quantity=1}) {
  return this.SendMessage({
    action: "purchasePrice",
    params: {
      tenantSlug,
      marketplaceSlug,
      marketplaceId,
      marketplaceHash,
      listingId,
      sku,
      quantity
    }}
  );
};

/**
 * &lt;b>&lt;i>Prompts user for consent&lt;/i>&lt;/b>
 *
 * Initiate opening of the specified pack
 *
 * @methodGroup Packs
 * @namedParams
 * @param {string} contractAddress - The address of the NFT contract
 * @param {string} tokenId - The token ID of the item
 */
exports.OpenPack = async function ({contractAddress, tokenId}) {
  Assert("OpenPack", "Contract address", contractAddress);
  Assert("OpenPack", "Token ID", tokenId);

  return await this.SendMessage({
    action: "openPack",
    params: {
      contractAddress,
      tokenId
    }
  });
};

/**
 * Retrieve the status of the specified pack opening.
 *
 * The returned status has two parts:
 &lt;ul>
 &lt;li>- status - The status of the open process. When the finished, this status will be COMPLETE. If the process failed, this status will be FAILED.&lt;/li>
 &lt;li>- items - If opening has succeeded, a list of the items received will be included.&lt;/li>
 &lt;ul>
 *
 * @methodGroup Packs
 * @namedParams
 * @param {string} contractAddress - The address of the NFT contract
 * @param {string} tokenId - The token ID of the item
 *
 * @return {Promise&lt;Object>} - The status of the pack opening
 */
exports.PackOpenStatus = async function({contractAddress, tokenId}) {
  Assert("PackOpenStatus", "Contract address", contractAddress);
  Assert("PackOpenStatus", "Token ID", tokenId);

  return await this.SendMessage({
    action: "packOpenStatus",
    params: {
      contractAddress,
      tokenId
    }
  });
};
</code></pre>
</div>

    



        <footer class="footer">
          Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a>
        </footer>
      </div>
    </div>
  </div>

  <script>
    // Format and add line numbers to code
    prettyPrint();
  </script>

  <script type="text/javascript" src="scripts/utils.js"></script>

  </body>
</html>
